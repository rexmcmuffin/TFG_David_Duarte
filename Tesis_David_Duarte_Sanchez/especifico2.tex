\chapter{Flujo de trabajo para la implementación de software para GNC embebido}
\label{ch:especifico2}

Como se pudo observar en el capítulo \ref{ch:especifico1}, se realizó la selección de la tarjeta de desarrollo Zedboard para el desarrollo del proyecto, además de esto uno de los parámetros que se tomó en cuenta fue la compatibilidad de esta tarjeta con el flujo de trabajo de Yocto Project, es por esto que en este capítulo se pretenden establecer los flujos de trabajo para el prototipado de algoritmos de control de orientación y navegación para aplicaciones espaciales. Esto mediante el uso de MATLAB Simulink para tomar un caso de estudio como ejemplo, seguido de esto convertir el código por medio de la transformación de modelo de Simulink a un modelo de código C, esto con el objetivo de poder embeber el código C en una imagen mínima por medio del flujo de trabajo de Yocto Project y finalmente probar el mismo en la tarjeta de desarrollo seleccionada en el capítulo \ref{ch:especifico1} y de esta forma poder comparar los resultados obtenidos y el tiempo de ejecución que llevo la tarea en el computador y en el sistema embebido.


\begin{figure}[h!]
    \centering
    \includegraphics[width=0.3\textwidth]{fig/figtemplate.pdf}
    \caption{Diagrama general del flujo de trabajo propuesto}
    \label{fig:diagrama_flujo_trabajo}
\end{figure}


En la Figura \ref{fig:diagrama_flujo_trabajo}, se muestra un diagrama del flujo de trabajo general. En este capítulo se trabajará en la sección remarcada en rojo la cual engloba la generación del modelo utilizado como caso de estudio, la validación del mismo en MATLAB Simulink, la generación de un código en lenguaje C y la incorporación del mismo en el flujo de trabajo de Yocto Project.

\section{Flujo de trabajo de la aplicación Model 2 Model Transformation}

Para poder embeber el sistema se debe de hacer uso del MATLAB Simulink Coder, el cual tiene la capacidad de convertir un sistema de conrtol generado en MATLAB Simulink, en un codigo C, algunos de los parametros que se pueden configurar en este convertidor de modelos son:

\begin{itemize}
    \item 
\end{itemize}

A lo largo de este capitulo se definiran los parametros que se deben de utilar y el funcionamiento de estos dentro de la generacion del codigo C.

\section{Selección del caso de estudio}

Como caso de estudio se selecciono una aplicacion la cual permitiera una comparacion de resultados antes del procesado y despues del mismo, es por esto que se decidio implementar un filtro  de tipo xxx haciendo uso de los siguientes bloques de MATLAB Simulink. 

\begin{itemize}
    \item Onda seno
    \item Suma
    \item Función de transferencia
    \item Generador de archivo de salida
\end{itemize}

La configuracion seleccionada para el primer generador de onda seno es:

\begin{itemize}
    \item Amplitud = 1
    \item Bias = 0 
    \item Frecuencia = 1 rad/s
    \item Fase = 0 
    \item Tiempo de muestreo = 0 
\end{itemize}

Mientars que para la segunda onda se tiene la configuracion:

\begin{itemize}
    \item Amplitud = 1
    \item Bias = 0 
    \item Frecuencia = 12 rad/s
    \item Fase = 0 
    \item Tiempo de muestreo = 0 
\end{itemize}

Esto con el objetivo de sumar las ondas y que las mismas (explicar que pasa al sumar dos ondas de distinta frecuencia)

Por otro lado la funcion de transferencia a utilizar sera:

ingresar la funcion de transferencia

esto con el fin de separar las frecuencias anteriormente sumadas y obtener una salida con la (describir que se espera a la salida)

Estos bloques mencionados anteriormente se lococan como se muestra en la Figura \ref{}, de modo que se obtienen como salida del sistema 2 archivos, uno llamado xxx el cual contiene los datos crudos de la suma de las dos sennales y otro denomindado, xxxx el cual contiene los datos de la sennnal filtrada por la funcion de tranferencia. 

\subsection{Simulacion del caso de estudio en Matlab Simulink}\label{subsec:simulacion_caso_de_estudio}

Utilizando el diagrama de la Figura \ref{} asi como usando los parametros configurados anteriormente se colocan dos bloques de grafico en el diagrama como se muestra en la Figura \ref{}, esto con el objetivo de poder observar las senales de salida en cada uno de los puntos de interes. 

(imagen compuesta por dos graficos uno al lado del otro donde a la derecha mostremos las senales sumadas y a la derecha las senales filtradas)

Como se puede observar en la Figura \ref{} se puede observar la salida de la suma de las dos senales senoidales, por otro lado en la Figura \ref{} se puede observar la salida de la funcion de transferencia.

\subsubsection{Resultados obtenidos con la ejecución de la simulacionn}

Como se menciono anteriormente los resultados obtenidos se pueden observar en la Figura \ref{}, siendo la salida esperada de la funcion de transferencia ya que al ser un filtro paso xxx atenua las senales que sten por debajo de la frencuencia de corte que para este filtro es de xxx. Como la senal compuesta contiene una senal con frecuencia de xxxx y otra con frencuencia de xxxx es posible observar aun componentes de la frecuencia atenuada.

\subsection{Simulink coder}

Una vez comprobado el comportamiento esperado por el caso de estudio se puede proceder con la ejecucion del flujo de trabajo de MATLAB Simulink coder, esto con el fin de transformar el modelo generado en Simulink a un modelo de lenguaje de programacion C. Cabe destacar que para esta implementacion se utilizo el diagrama que se muestra en la Figura \ref{} ya que el mismo solamente contiene los archivos con los datos numericos del sistema y no contiene las salidas graficas agregadas en \ref{subsec:simulacion_caso_de_estudio}.


\subsection{Definicio de paramtetros}

Para la definicion de parametros, se debe de estar en el entorno de MATLAB Simulink, una vez en el entorno mencionado anteriormente se debe ir a la pestanna denominada Aplicaciones, como se muestra en la Figura \ref{}, se debera de seleccionar la aplicacion denominada Simulink Coder, cuando seleccionamos esta opcion se abrira una pestanna llamada Codigo C, como se pudo observar en la Figura \ref{}, una vez estemos en la pestanna de codigo C, debemos de ir a la opcion de configuracion de parametros, tal y como se muestra en la Figura \ref{}, una vez presionada la opcion se abre una ventana emergente como la que se muestra en la Figura \ref{}, en la pestanna denominada Solver se deberan de proporcionar los datos de Tiempo de inicio y Tiempo de finalzacion de la simulacion.

\subsubsection{seleccion del procesador objetivo}

Continuando en la seccion de configuracion de parametros ahora debemos de ir a la pestanna llamada Hardware Implementation, en donde deberemos de colocar los datos de Device Vendor el cual para nuestro caso seria ARM Compatible y el Device Type que seria un ARM Cortex-A de 32-bits tal y como se muestra en la Figura \ref{}.


\subsubsection{Seleccion del tipo de archivo de construccion}

Ahora bien, anteriormente configuramos los parametros de de tiempo de operacion y procesador de la tarjeta de desarrollo, ahora debemos de configurar el tipo de archivo que se utilizara para la generacion de los archivos, como se debera de realziar una compilacion cruzada se debe de elegit un tipo de archivo el cual nos permita compilar los binarios para la ejecucion del sistema sin importar el sistema operativo de la maquina host. Es por esto que se debe de seleccionar en la pestanna de Code Generation el Toolchain denominado CMake tal y como se muestra en la Figura \ref{}.


\subsubsection{Generacion de archivos de compilacion}

Una vez configurados todos los parametros mencionados anteriormente debemos de proceder con la construccion de los archivos, para esto se debe de ir a la barra de tareas a la opcion denominada como generar codigo

\subsection{Contenedor para compilacion de los binarios}

se geenra un container por emdio de docker io, este debera de ejecutar la imafen dew linux 20.04 esto debido a la dependencia de la libreria GCC 2.30 que presenta yocto a la hora de compilar los arhcivoso
se instalan las herramientas requeridas

\subsubsection{Istalacion de programas en el contenedor}

instalamos el cross compiler y las dependencias del mismo

\subsection{Compilacion de los binarios}

Compilamos los binarios para su ejecucion en

Una vez compilados los binarios se puede continuar con el flujo que se presneta en el diagrama que se muestra en la Figura XX, lo cual seria la implemetnacion de los binarios en una imagen de yocto. mediante los pasos que se muestran en la siguiente seleccion


\subsection{Caso de estudio}


\section{Flijo de Trabajo Herramienta desarrollada por mi persona}
Diagrama de pasos para poder ejecutar el flujo de trabajo

\subsection{Sistema operativo para desarrollo}
hablar sobre el sistema operativo base que se reqiere para generar el flujo, version de kernel y demas daros 

\subsection{Generacion de un contenedor}
por que se debe de utilizar un contenedor para fines del proyecto
\subsubsection{Creacion de un usuario no root}
por que se requiere generar un usuario no root 
\subsection{Yocto Project}
referencar al marco teorico de que es y para que se esta utilizando en el desarrollo del marco de trabajo
\subsection{creacion de una capa de yocto}
como se debe de generar una capa en yocto
\subsection{Caso de estudio}
\subsection{integracion del programa generado a la capa de yocto}
como se debe de intgrar y para que funciona cada comando del .bb de la capa
\subsection{Generacion de la imagen minima}
Por que se usa una imagen minima 
\subsection{Implementacion de la imagen minima en la tarjeta de desarrollo zedboard}
Como se debe de implementar el boot de la tarjeta, como se debe de implementar el  sistema de archivos
\subsection{Conexion de la tarjeta de desarrollo con el computador host}
diagrama de conexion y programas utilizados para llevar a cabo el enlace

\subsection{Ejecucion del caso de estudio y resultados}

\subsection{Comparacion de resultados}

\section{Reflexion final}